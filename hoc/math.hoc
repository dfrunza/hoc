int max(int a, int b)
{
  int result; result = a;
  if(a < b)
    result = b;
  return result;
}

int min(int a, int b)
{
  int result; result = a;
  if(a > b)
    result = b;
  return result;
}

float maxf(float a, float b)
{
  float result; result = a;
  if(a < b)
    result = b;
  return result;
}

float minf(float a, float b)
{
  float result; result = a;
  if(a > b)
    result = b;
  return result;
}

int abs(int a)
{
  if(a < 0)
    a = -a;
  return a;
}

float absf(float a)
{
  if(a < 0.0)
    a = -a;
  return a;
}

int gcd_recurs(int a, int b)
{
  int result; result = a;
  if(b <> 0)
  {
    result = b;
    int r; r = a mod b;
    if(r == 0)
      result = b;
    else
      result = gcd_recurs(b, r);
  }
  return result;
}

int gcd_iter(int a, int b)
{
  while(a <> b)
  {
    if(a > b)
      a = a - b;
    else
      b = b - a;
  }
  return a;
}

/*
   Greatest Common Divisor
 */
int gcd(int a, int b)
{

  return gcd_recurs(abs(a), abs(b));
  /*
  return gcd_iter(abs(a), abs(b)); */
}

/*
   Least Common Multiple
 */
int lcm(int a, int b)
{
  return abs(a * b)/gcd(a, b);
}

float ipow(float a, int p)
{
  bool inv; inv = (p < 0);
  p = abs(p);

  float result; result = 1.0;
  if(p <> 0)
  {
    while(p > 0)
    {
      result = result * a;
      p = p - 1;
    }
    if(inv)
      result = 1.0/result;
  }
  return result;
}

float sqrt_iter(float x, float g)
{
  float r; r = x/g;

  if(r <> g)
  {
    r = (r+g) / 2.0;
    if(absf(r-g) == 1.0)
      r = minf(r, g);
  }
  return r;
}

/*
   Computes the largest number 'r' such that 'r^r <= x'
FIXME: sqrt(100.0) gives a funky result.
 */
float sqrt(float x)
{
  float g; g = x;
  float r; r = 1.0;

  while((g > 0.0) and (g <> r))
  {
    g = r;
    r = sqrt_iter(x, g);
  }
  return g;
}

/*
   Integer log_b of n : the largest integer x such that
      pow(b, x) <= n
*/
int floor_log_b(int b, float n)
{
  int x; x = 0;
  float b_pow_x; b_pow_x = 1.0;

  if(n > 1.0)
  {
    while(n > b_pow_x)
    {
      x = x + 1;
      b_pow_x = ipow((float):b, x);
    }
    x = x - 1;
  }
  else if(n < 1.0)
  {
    while(b_pow_x > n)
    {
      b_pow_x = ipow((float):b, x);
      x = x - 1;
    }
    x = x + 1;
  }

  return x;
}

/* Returns the number of significand 10-base digits */
int fp_bin_to_dec(float v, []int significand, []int exponent)
{
  float v_abs; v_abs = absf(v);
  int x; x = floor_log_b(10, v_abs) + 1;
  exponent[0] = x;

  float B_power_x; B_power_x = ipow(10.0, -x);
  float v_prime; v_prime = v_abs * B_power_x;

  int k; k = 0;
  float R; R = v_prime;
  float M; M = ipow(2.0, -23) / 2.0; /* 23 is the width of the significand of single precision binary FP */
  int U;

  bool run_loop; run_loop = true;
  while(run_loop)
  {
    k = k + 1;
    U = (int):(R * 10.0);
    R = (R * 10.0) - (float):U;
    M = M * 10.0;
    significand[k] = U;

    run_loop = (R >= M) and (R <= (1.0 - M));
  }

  if(R <= 0.5)
    significand[k] = U;
  else
    significand[k] = U + 1;

  return k;
}

