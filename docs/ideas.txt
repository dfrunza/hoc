DYM
NEWK
Suggestions to improve C:

- The '.' operator should dereference pointers.
  No excuse for '->'.

- A function with a pointer-type argument should automatically reference a non-pointer object.
  No excuse for & everywhere.

- Allow the ability to continue or break out of loops by the name of their iterator.

- Add the ability to compare with, assign to, or iterate across slices of arrays or strings.

- Declaring an enum, struct, or union should declare the type of it as well.
  People shouldn't be forced to type 'enum', 'struct', and 'union' everywhere.

- Don't let enums pollute the global namespace unless they're anonymous.
  And if structs or unions are anonymous, pollute the hell out of it. My intentions are clear.

- How about a 'countof' operator that does the equivalent of `sizeof(x) / sizeof(*x)`?
  Screw the last idea, why not get rid of all *of operators and have meta-attributes?
     x\size;  x\type;  x\count;

- Coroutines (https://handmade.network/forums/t/2311-thoughts_on_coroutines#12266)

--------

G.Bill

Thing x;
int err = init_thing(&x);
if(!err)
{
  ...
}
else defer {
  destroy_thing(&x);
}

if(a)
{
  ...
}
else if(b) defer {

}

-------------
Break out of n-nested loops

for(int i = 0; i < 100; i++)
{
  for(int j = 0; j < 50; j++)
  {
    // break to the enclosing scope of the for-i loop
    break^2;
  }
}

-------------

Consider the structures :

struct AstNode
{
  Type type;
  AstId id;
}

struct AstId
{
  char* name;
  int scope;
  ...
}

Now consider the procedure :

label(AstNode* id)
{
  assert(id->kind == AstNodeKind_Id);
  ...
}

The `id` argument is of base type `AstNode`. The problem is that the checking of the type of the argument
is done at runtime via the assertion.

We want to statically check the invocations of the procedure :

label(AstId* id)
{
  ...
}

But now we can't access the base type anymore.
One solution is to have a pointer to the base type inside the subtype :

struct AstId
{
  AstNode* node;
  ...
}

Are there other ways to do this?

Could the compiler calculate at compile time the pointer to the "enclosing" `AstNode`,
given a pointer to `AstId`?

AstNode node = {};
AstId* id = &node.id;
AstNode* node_id = id^; // UP one level in the enclosure hierarchy

&node == (&node.id)^;  // true statement

id^.type; // go up one level from `id` then access `type`

char* name = node.id.name;
name^2.type; // go up 2 levels from `id` then access `type`

------------------------
NAMESPACE
Importation of names into the current scope.

use node.*;
label->id = id;

use node.label;
label->id = id;

use node.*
{
  label->id = id;
}

use node.*, id.label; // if there's a conflict, compiler should raise an alert
type = ...; // from node
label = ...; // from id

{
  use &(*node)->goto_stmt.*;
  .id = new_id();
  .name = new_name();
}

use &(*node)->goto_stmt;
goto_stmt.id = id;
goto_stmt.name = name;

{
  use node->a.*, node->b.*;
  var int x, int y;
}

----------------------
Complex numbers in Odin:

var a = 3 + 4i;

------------------------
FUNCTION POINTERS

var int* proc(int a, int b)* f = 0;
var proc int* (int a, int b)* f = 0;
var proc int* F(int a, int b)* f = 0;
F* f;
proc int* F(int a, int b);
F* p_f;
proc int* f(int a, int b);


---------------------------------------
TYPES AND PROC POINTERS

proc void roar(Animal* a)
{
  if(a->kind == AnimalKind.Cat)
    // do the meow
  else if(a->kind == AnimalKind.Dog)
    // do the bark
  else if(a->kind == AnimalKid.Mouse)
    // do the squeak
}

..............................
WITH TYPES 1

type AnimalKind: enum
{
  Cat,
  Dog,
  Mouse
}

type Animal: struct
{
  AnimalKind kind;
  int roar_strength;
}

type Roar: proc int (Animal* a);

/* var decls */
Roar* p_roar; // proc ptr
Animal* animal;

p_roar = &roar;
p_roar(animal); // call proc

WITH TYPES 2

type enum AnimalKind
{
  Cat,
  Dog,
  Mouse
}

type struct Animal
{
  AnimalKind kind;
  int roar_strength;
}

type proc int* Roar(int a);

/* var decls */
Roar* roar; // proc ptr
Animal* animal;

p_roar = &roar;
p_roar(animal); // call proc

........................
WITH TYPES 3

type main proc int main()
{
  return sqrt_floor(23);
}

var main* p_main;
p_main();

type A struct A
{
};

type char8 char;
type A proc int foo();
type E enum E {a, b, c};

var enum E e;
var E e;
var E* e1, e2;
var []E* aye1;

..........................
WITHOUT TYPES

enum AnimalKind
{
  Cat,
  Dog,
  Mouse
}

struct Animal
{
  AnimalKind kind;
  int roar_strength;
}

var proc roar* p_roar; // ptr to proc `roar`

var proc void roar(Animal* a)* p_roar;
var proc void (Animal* a)* p_roar;

proc void roar(struct Animal* a);
var roar* p_roar; // ptr to proc type `roar`

-----------------------------
var int* a[]; // array of int pointers
var int* proc(int)* p_proc; // pointer to proc
var int* proc(int)* p_proc[10]; // array of 10 pointers to proc
var struct {int a;} *a[10], **b;

------------------------------
var [10]( [10]int* proc(int) )* p_func; // p_func is an array of proc pointers; the proc returns an array of ints
var ([] ([]int* proc(int))* )* p_func; // p_func is a pointer to an array of proc pointers
-------------------------------



