extern int GetStdHandle(int device_id);
extern void ExitProcess(int code);
extern char^ GetCommandLineA();
extern void^ VirtualAlloc(void^ address, int alloc_size, int alloc_var, int protect_flags);
extern void WriteConsoleA(int console_handle, []char buf, int chars_to_write_count, int^ chars_written_count, void^ reserved);
extern int GetLastError();
extern bool ReadFile(int file_handle, []char buf, int bytes_to_read_count, int^ bytes_read_count, void^ p_overlapped);

void main()
{
  float a; a = 1.0064;
  print_float(a);
  print_str(&"\n");

  []char cmd; cmd = GetCommandLineA();
  print_str(cmd);
}

int stdout;
int stdin; 
void^ heap;
int heap_ptr;

void^ alloc(int size)
{
  void^ mem; mem = heap + (void^):heap_ptr;
  heap_ptr = heap_ptr + size;
  return mem;
}

int stdin_read([]char buf, int buf_size)
{
  int bytes_read_count; bytes_read_count = 0;
  if(ReadFile(stdin, buf, buf_size, &bytes_read_count, (void^):0))
  {
    if((bytes_read_count >= 0) and (bytes_read_count < buf_size))
    {
      buf[bytes_read_count] = '\0';
    }
  }
  return bytes_read_count;
}

void startup()
{
  int STD_OUTPUT_HANDLE; STD_OUTPUT_HANDLE = -11;
  int STD_INPUT_HANDLE; STD_INPUT_HANDLE = -10;

  int MEM_COMMIT; MEM_COMMIT = 0x1000;
  int MEM_RESERVE; MEM_RESERVE = 0x2000;
  int PAGE_READWRITE; PAGE_READWRITE = 0x4;

  stdout = GetStdHandle(STD_OUTPUT_HANDLE);
  stdin = GetStdHandle(STD_INPUT_HANDLE);

  heap = VirtualAlloc((void^):0, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
  heap_ptr = 0;

  main();
}

void str_copy([]char dest_str, []char src_str)
{
  int i; i = 0;
  do
  {
    dest_str[i] = src_str[i];
    i = i + 1;
  }
  while(src_str[i] <> '\0');
}


int str_len([]char str)
{
  int len; len = 0;
  while(str[len] <> '\0')
  {
    len = len + 1;
  }
  return len;
}

void print_str([]char str)
{
  int len; len = str_len(str);
  int chars_written_count; chars_written_count = 0;
  WriteConsoleA(stdout, str, len, &chars_written_count, (void^):0);
}

void digit_to_char([]char buf, int pos, int digit)
{
  if(digit == 0)
    buf[pos] = '0';
  else if(digit == 1)
    buf[pos] = '1';
  else if(digit == 2)
    buf[pos] = '2';
  else if(digit == 3)
    buf[pos] = '3';
  else if(digit == 4)
    buf[pos] = '4';
  else if(digit == 5)
    buf[pos] = '5';
  else if(digit == 6)
    buf[pos] = '6';
  else if(digit == 7)
    buf[pos] = '7';
  else if(digit == 8)
    buf[pos] = '8';
  else if(digit == 9)
    buf[pos] = '9';
  else
    buf[pos] = '?';
}

[]char int_to_str([]char buf, int buf_len, int i)
{
  int buf_i; buf_i = buf_len - 1;
  buf[buf_i] = '\0';

  bool is_negative; is_negative = false;
  if(i < 0)
  {
    i = abs(i);
    is_negative = true;
  }

  buf_i = buf_i - 1;
  int remainder; remainder = i mod 10;
  digit_to_char(buf, buf_i, remainder);

  while(i > remainder)
  {
    buf_i = buf_i - 1;
    i = (i - remainder) / 10;
    remainder = i mod 10;
    digit_to_char(buf, buf_i, remainder);
  }

  if(is_negative)
  {
    buf_i = buf_i - 1;
    buf[buf_i] = '-';
  }

  return buf + (char^):buf_i;
}

void init_intbuf([]int buf, int len, int val)
{
  int i; i = 0;
  while(i < len)
  {
    buf[i] = val;
    i = i + 1;
  }
}

void float_to_str([]char buf, int buf_len, float f)
{
  [9]int significand;
  init_intbuf(&significand, 9, 0);
  int exponent; exponent = 0;

  int digit_count; digit_count = fp_bin_to_dec(f, &significand, &exponent);

  int pos; pos = 0;

  if(f < 0.0)
  {
    buf[pos] = '-';
    pos = pos + 1;
  }

  int i; i = 1;
  if(exponent <= 0)
  {
    buf[pos] = '0';
    pos = pos + 1;
    buf[pos] = '.';
    pos = pos + 1;
  }
  else
  {
    while((i <= digit_count) and (exponent > 0))
    {
      digit_to_char(buf, pos, significand[i]);
      i = i + 1;
      pos = pos + 1;
      exponent = exponent - 1;
    }

    buf[pos] = '.';
    pos = pos + 1;
    if(i > digit_count)
    {
      buf[pos] = '0';
      pos = pos + 1;
    }
  }

  while(i <= digit_count)
  {
    digit_to_char(buf, pos, significand[i]);
    i = i + 1;
    pos = pos + 1;
  }

  if(exponent <> 0)
  {
    buf[pos] = 'e';
    pos = pos + 1;

    [20]char exponent_buf;
    []char exponent_str; exponent_str = int_to_str(&exponent_buf, 20, exponent);
    while(^exponent_str <> '\0')
    {
      buf[pos] = ^exponent_str;
      exponent_str = exponent_str + (char^):1;
      pos = pos + 1;
    }
  }

  buf[pos] = '\0';
}

void print_int(int i)
{
  [20]char buf;
  print_str(int_to_str(&buf, 20, i));
}

void print_float(float f)
{
  [20]char buf;
  float_to_str(&buf, 20, f);
  print_str(&buf);
}

void print_bool(bool b)
{
  if(b)
    print_str(&"true");
  else
    print_str(&"false");
}

int max(int a, int b)
{
  int result; result = a;
  if(a < b)
    result = b;
  return result;
}

int min(int a, int b)
{
  int result; result = a;
  if(a > b)
    result = b;
  return result;
}

float maxf(float a, float b)
{
  float result; result = a;
  if(a < b)
    result = b;
  return result;
}

float minf(float a, float b)
{
  float result; result = a;
  if(a > b)
    result = b;
  return result;
}

int abs(int a)
{
  if(a < 0)
    a = -a;
  return a;
}

float absf(float a)
{
  if(a < 0.0)
    a = -a;
  return a;
}

float ipow(float a, int p)
{
  bool inv; inv = (p < 0);
  p = abs(p);

  float result; result = 1.0;
  if(p <> 0)
  {
    while(p > 0)
    {
      result = result * a;
      p = p - 1;
    }
    if(inv)
      result = 1.0/result;
  }
  return result;
}

int floor_log_b(int b, float n)
{
  int x; x = 0;
  float b_pow_x; b_pow_x = 1.0;

  if(n > 1.0)
  {
    while(n >= b_pow_x)
    {
      x = x + 1;
      b_pow_x = ipow((float):b, x);
    }
    x = x - 1;
  }
  else if(n < 1.0)
  {
    while(b_pow_x > n)
    {
      b_pow_x = ipow((float):b, x);
      x = x - 1;
    }
    x = x + 1;
  }

  return x;
}

int fp_bin_to_dec(float v, []int significand, []int exponent)
{
  float v_abs; v_abs = absf(v);
  int x; x = floor_log_b(10, v_abs) + 1;
  exponent[0] = x;

  float B_power_x; B_power_x = ipow(10.0, -x);
  float v_prime; v_prime = v_abs * B_power_x;

  int k; k = 0;
  float R; R = v_prime;
  float M; M = ipow(2.0, -23) / 2.0;
  int U;

  bool run_loop; run_loop = true;
  while(run_loop)
  {
    k = k + 1;
    U = (int):(R * 10.0);
    R = (R * 10.0) - (float):U;
    M = M * 10.0;
    significand[k] = U;

    run_loop = (R >= M) and (R <= (1.0 - M));
  }

  if(R <= 0.5)
    significand[k] = U;
  else
    significand[k] = U + 1;

  return k;
}

