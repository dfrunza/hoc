TODO
----
- Reserve decl_block_offset=0 for module-leve (global) block.

DYM
NEWK
Suggestions to improve C:

- The '.' operator should dereference pointers.
  No excuse for '->'.

- A function with a pointer-type argument should automatically reference a non-pointer object.
  No excuse for & everywhere.

- Allow the ability to continue or break out of loops by the name of their iterator.

- Add the ability to compare with, assign to, or iterate across slices of arrays or strings.

- Declaring an enum, struct, or union should declare the type of it as well.
  People shouldn't be forced to type 'enum', 'struct', and 'union' everywhere.

- Don't let enums pollute the global namespace unless they're anonymous.
  And if structs or unions are anonymous, pollute the hell out of it. My intentions are clear.

- How about a 'countof' operator that does the equivalent of `sizeof(x) / sizeof(*x)`?
  Screw the last idea, why not get rid of all *of operators and have meta-attributes?
     x\size;  x\type;  x\count;

- Coroutines (https://handmade.network/forums/t/2311-thoughts_on_coroutines#12266)

--------

G.Bill

Thing x;
int err = init_thing(&x);
if(!err)
{
  ...
}
else defer {
  destroy_thing(&x);
}

if(a)
{
  ...
}
else if(b) defer {

}

-------------
Break out of n-nested loops

for(int i = 0; i < 100; i++)
{
  for(int j = 0; j < 50; j++)
  {
    // break to the enclosing scope of the for-i loop
    break^2;
  }
}

-------------

Consider the structures :

struct AstNode
{
  Type type;
  AstId id;
}

struct AstId
{
  char* name;
  int scope;
  ...
}

Now consider the procedure :

label(AstNode* id)
{
  assert(id->kind == AstNodeKind_Id);
  ...
}

The `id` argument is of base type `AstNode`. The problem is that the checking of the type of the argument
is done at runtime via the assertion.

We want to statically check the invocations of the procedure :

label(AstId* id)
{
  ...
}

But now we can't access the base type anymore.
One solution is to have a pointer to the base type inside the subtype :

struct AstId
{
  AstNode* node;
  ...
}

Are there other ways to do this?

Could the compiler calculate at compile time the pointer to the "enclosing" `AstNode`,
given a pointer to `AstId`?

AstNode node = {};
AstId* id = &node.id;
AstNode* node_id = id^; // UP one level in the enclosure hierarchy

&node == (&node.id)^;  // true statement

id^.type; // go up one level from `id` then access `type`

char* name = node.id.name;
name^2.type; // go up 2 levels from `id` then access `type`

------------------------
NAMESPACE
Importation of names into the current scope.

use node.*;
label->id = id;

use node.label;
label->id = id;

use node.*
{
  label->id = id;
}

use node.*, id.label; // if there's a conflict, compiler should raise an alert
type = ...; // from node
label = ...; // from id

{
  use &(*node)->goto_stmt.*;
  .id = new_id();
  .name = new_name();
}

use &(*node)->goto_stmt;
goto_stmt.id = id;
goto_stmt.name = name;

{
  use node->a.*, node->b.*;
  var int x, int y;
}

----------------------
Complex numbers in Odin:

var a = 3 + 4i;

------------------------
FUNCTION POINTERS

var int* proc(int a, int b)* f = 0;
var proc int* (int a, int b)* f = 0;

---------------------------------------
TYPES AND PROC POINTERS

proc void roar(Animal* a)
{
  if(a->kind == AnimalKind.Cat)
    // do the meow
  else if(a->kind == AnimalKind.Dog)
    // do the bark
  else if(a->kind == AnimalKid.Mouse)
    // do the squeak
}

..............................
WITH TYPES 1

typedef enum AnimalKind
{
  Cat,
  Dog,
  Mouse
};

typedef struct Animal
{
  AnimalKind kind;
  int roar_strength;
};

typedef proc int (*Roar)(Animal* a);

/* var decls */
Roar p_roar; // proc ptr
Animal* animal;

p_roar = &roar;
p_roar(animal); // call proc

........................

proc void roar(int a)
{
  // do the roar
}

var proc roar *p_roar; // p_roar is a pointer to proc roar

-----------------------------

proc void foo(MyLocalType* e)
{
  struct MyLocalType {
    ...
  };

  MyLocalType a;
  foo(&a);
}


---------------------------------

struct Shape
{
  V2 pos;
}

struct Circle
{
  Shape;
  float radius;
}

struct Rectangle
{
  Shape;
  int width, height;
}

T clone(T* t) : T = (Circle, Rectangle)
{
  T* result = new(T);
  *result = *t;
  return result;
}
